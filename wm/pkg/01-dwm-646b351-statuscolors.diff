diff --git a/config.def.h b/config.def.h
index 3fde3cf..a7ef27a 100644
--- a/config.def.h
+++ b/config.def.h
@@ -4,17 +4,22 @@
 static const char *fonts[] = {
 	"monospace:size=10"
 };
-static const char dmenufont[]       = "monospace:size=10";
-static const char normbordercolor[] = "#444444";
-static const char normbgcolor[]     = "#222222";
-static const char normfgcolor[]     = "#bbbbbb";
-static const char selbordercolor[]  = "#005577";
-static const char selbgcolor[]      = "#005577";
-static const char selfgcolor[]      = "#eeeeee";
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const Bool showbar           = True;     /* False means no bar */
-static const Bool topbar            = True;     /* False means bottom bar */
+static const char dmenufont[]		= "monospace:size=10";
+static const char dmenunormbackground[]	= "#222222";
+static const char dmenunormforeground[]	= "#bbbbbb";
+static const char dmenuselbackground[]	= "#005577";
+static const char dmenuselforeground[]	= "#eeeeee";
+static const unsigned int borderpx	= 1;        /* border pixel of windows */
+static const unsigned int snap		= 32;       /* snap pixel */
+static const Bool showbar		= True;     /* False means no bar */
+static const Bool topbar		= True;     /* False means bottom bar */
+
+static const char *colorschemes[][3] = {
+	/* 12 colorschemes at max */
+	/* border, background, foreground */
+	{ "#444444", "#222222", "#bbbbbb" },	/* normscheme */
+	{ "#005577", "#005577", "#eeeeee" },	/* selscheme */
+};
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
@@ -54,7 +59,7 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", dmenunormbackground, "-nf", dmenunormforeground, "-sb", dmenuselbackground, "-sf", dmenuselforeground, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
 static Key keys[] = {
diff --git a/drw.c b/drw.c
index f49200b..77405c0 100644
--- a/drw.c
+++ b/drw.c
@@ -219,10 +219,10 @@ drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int
 }
 
 int
-drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert)
+drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert, int lmargin, int rmargin)
 {
 	char buf[1024];
-	int tx, ty, th;
+	int tx, ty, th, tw;
 	Extnts tex;
 	XftDraw *d = NULL;
 	Fnt *curfont, *nextfont;
@@ -250,6 +250,15 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 		                  DefaultColormap(drw->dpy, drw->screen));
 	}
 
+	tw = drw->fonts[0]->h / 2;
+	if (lmargin) {
+		x += tw;
+		w = (w < tw ? 0 : w - tw);
+	}
+	if (rmargin) {
+		w = (w < tw ? 0 : w - tw);
+	}
+
 	curfont = drw->fonts[0];
 	while (1) {
 		utf8strlen = 0;
@@ -279,7 +288,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 		if (utf8strlen) {
 			drw_font_getexts(curfont, utf8str, utf8strlen, &tex);
 			/* shorten text if necessary */
-			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - drw->fonts[0]->h || w < drw->fonts[0]->h); len--)
+			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && tex.w > w; len--)
 				drw_font_getexts(curfont, utf8str, len, &tex);
 
 			if (len) {
@@ -291,7 +300,7 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 				if (render) {
 					th = curfont->ascent + curfont->descent;
 					ty = y + (h / 2) - (th / 2) + curfont->ascent;
-					tx = x + (h / 2);
+					tx = x;
 					XftDrawStringUtf8(d, invert ? &drw->scheme->bg->rgb : &drw->scheme->fg->rgb, curfont->xfont, tx, ty, (XftChar8 *)buf, len);
 				}
 				x += tex.w;
@@ -347,6 +356,9 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 	if (d)
 		XftDrawDestroy(d);
 
+	if (rmargin) {
+		x += tw;
+	}
 	return x;
 }
 
diff --git a/drw.h b/drw.h
index e3b8515..c9ac2f8 100644
--- a/drw.h
+++ b/drw.h
@@ -68,7 +68,7 @@ void drw_setscheme(Drw *, ClrScheme *);
 
 /* Drawing functions */
 void drw_rect(Drw *, int, int, unsigned int, unsigned int, int, int, int);
-int drw_text(Drw *, int, int, unsigned int, unsigned int, const char *, int);
+int drw_text(Drw *, int, int, unsigned int, unsigned int, const char *, int, int, int);
 
 /* Map functions */
 void drw_map(Drw *, Window, int, int, unsigned int, unsigned int);
diff --git a/dwm.c b/dwm.c
index 96b43f7..59e3e60 100644
--- a/dwm.c
+++ b/dwm.c
@@ -51,11 +51,15 @@
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
+#define MAXCOLORS               12
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_text(drw, 0, 0, 0, 0, (X), 0) + drw->fonts[0]->h)
+#define TEXTWM(X, L, R)         (drw_text(drw, 0, 0, 0, 0, (X), 0, (L), (R)))
+#define TEXTW(X)                (TEXTWM((X), 1, 1))
+#define CTEXTW(X)               (drawcoloredtext(0, 0, 0, 0, (X), 0))
+
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
@@ -164,6 +168,7 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
+static int drawcoloredtext(int x, int y, unsigned int w, unsigned int h, char *text, int invert);
 static void enternotify(XEvent *e);
 static void expose(XEvent *e);
 static void focus(Client *c);
@@ -261,7 +266,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static Bool running = True;
 static Cur *cursor[CurLast];
-static ClrScheme scheme[SchemeLast];
+static ClrScheme scheme[MAXCOLORS];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -273,6 +278,9 @@ static Window root;
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
+/* compile-time check if we have mandatory schemes and all colorschemes fit into scheme array. */
+struct NumColors { char limitexceeded[LENGTH(colorschemes) > MAXCOLORS || LENGTH(colorschemes) < SchemeLast ? -1 : 1]; };
+
 /* function implementations */
 void
 applyrules(Client *c) {
@@ -432,7 +440,7 @@ buttonpress(XEvent *e) {
 		}
 		else if(ev->x < x + blw)
 			click = ClkLtSymbol;
-		else if(ev->x > selmon->ww - TEXTW(stext))
+		else if(ev->x > selmon->ww - CTEXTW(stext))
 			click = ClkStatusText;
 		else
 			click = ClkWinTitle;
@@ -474,7 +482,7 @@ cleanup(void) {
 		cleanupmon(mons);
 	for(i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for(i = 0; i < SchemeLast; i++) {
+	for(i = 0; i < LENGTH(colorschemes); i++) {
 		drw_clr_free(scheme[i].border);
 		drw_clr_free(scheme[i].bg);
 		drw_clr_free(scheme[i].fg);
@@ -704,24 +712,24 @@ drawbar(Monitor *m) {
 	for(i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
+		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i, 1, 1);
 		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
 		           occ & 1 << i, urg & 1 << i);
 		x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, &scheme[SchemeNorm]);
-	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
+	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0, 1, 1);
 	x += w;
 	xx = x;
 	if(m == selmon) { /* status is only drawn on selected monitor */
-		w = TEXTW(stext);
+		w = CTEXTW(stext);
 		x = m->ww - w;
 		if(x < xx) {
 			x = xx;
 			w = m->ww - xx;
 		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
+		drawcoloredtext(x, 0, w, bh, stext, 0);
 	}
 	else
 		x = m->ww;
@@ -729,7 +737,7 @@ drawbar(Monitor *m) {
 		x = xx;
 		if(m->sel) {
 			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
+			drw_text(drw, x, 0, w, bh, m->sel->name, 0, 1, 1);
 			drw_rect(drw, x + 1, 1, dx, dx, m->sel->isfixed, m->sel->isfloating, 0);
 		}
 		else {
@@ -748,6 +756,39 @@ drawbars(void) {
 		drawbar(m);
 }
 
+int
+drawcoloredtext(int x, int y, unsigned int w, unsigned int h, char *text, int invert) {
+	char *ptr = text, *buf = text, ch;
+	int xx = x, render;
+	unsigned int s = 1, ww, i;
+
+	if (!(render = x || y || w || h)) {
+		w = ~w;
+	}
+	while (*ptr) {
+		for (i = 0; (*ptr < 0) || (*ptr > LENGTH(colorschemes)); ++i, ++ptr);
+		if (i) {
+			ch = *ptr;
+			*ptr = 0;
+			ww = TEXTWM(buf, x == xx, ch == 0);
+			if (xx - x + ww > w) {
+				ww = w - xx + x;
+			}
+			if (render) {
+				drw_setscheme(drw, &scheme[s - 1]);
+				drw_text(drw, xx, 0, ww, h, buf, invert, x == xx, ch == 0);
+			}
+			*ptr = ch;
+			xx += ww;
+			if (!*ptr || ((xx - x) >= w))
+				break;
+		}
+		s = *ptr;
+		buf = ++ptr;
+	}
+	return xx - x;
+}
+
 void
 enternotify(XEvent *e) {
 	Client *c;
@@ -1496,6 +1537,7 @@ setmfact(const Arg *arg) {
 
 void
 setup(void) {
+	int i;
 	XSetWindowAttributes wa;
 
 	/* clean up any zombies immediately */
@@ -1530,12 +1572,11 @@ setup(void) {
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme[SchemeNorm].border = drw_clr_create(drw, normbordercolor);
-	scheme[SchemeNorm].bg = drw_clr_create(drw, normbgcolor);
-	scheme[SchemeNorm].fg = drw_clr_create(drw, normfgcolor);
-	scheme[SchemeSel].border = drw_clr_create(drw, selbordercolor);
-	scheme[SchemeSel].bg = drw_clr_create(drw, selbgcolor);
-	scheme[SchemeSel].fg = drw_clr_create(drw, selfgcolor);
+	for(i = 0; i < LENGTH(colorschemes); ++i) {
+		scheme[i].border = drw_clr_create(drw, colorschemes[i][0]);
+		scheme[i].bg = drw_clr_create(drw, colorschemes[i][1]);
+		scheme[i].fg = drw_clr_create(drw, colorschemes[i][2]);
+	}
 	/* init bars */
 	updatebars();
 	updatestatus();
