diff --git a/config.def.h b/config.def.h
index 3fde3cf..a7ef27a 100644
--- a/config.def.h
+++ b/config.def.h
@@ -4,17 +4,22 @@
 static const char *fonts[] = {
 	"monospace:size=10"
 };
-static const char dmenufont[]       = "monospace:size=10";
-static const char normbordercolor[] = "#444444";
-static const char normbgcolor[]     = "#222222";
-static const char normfgcolor[]     = "#bbbbbb";
-static const char selbordercolor[]  = "#005577";
-static const char selbgcolor[]      = "#005577";
-static const char selfgcolor[]      = "#eeeeee";
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const Bool showbar           = True;     /* False means no bar */
-static const Bool topbar            = True;     /* False means bottom bar */
+static const char dmenufont[]		= "monospace:size=10";
+static const char dmenunormbackground[]	= "#222222";
+static const char dmenunormforeground[]	= "#bbbbbb";
+static const char dmenuselbackground[]	= "#005577";
+static const char dmenuselforeground[]	= "#eeeeee";
+static const unsigned int borderpx	= 1;        /* border pixel of windows */
+static const unsigned int snap		= 32;       /* snap pixel */
+static const Bool showbar		= True;     /* False means no bar */
+static const Bool topbar		= True;     /* False means bottom bar */
+
+static const char *colorschemes[][3] = {
+	/* 12 colorschemes at max */
+	/* border, background, foreground */
+	{ "#444444", "#222222", "#bbbbbb" },	/* normscheme */
+	{ "#005577", "#005577", "#eeeeee" },	/* selscheme */
+};
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
@@ -54,7 +59,7 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", dmenunormbackground, "-nf", dmenunormforeground, "-sb", dmenuselbackground, "-sf", dmenuselforeground, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
 static Key keys[] = {
diff --git a/dwm.c b/dwm.c
index 96b43f7..ef6e644 100644
--- a/dwm.c
+++ b/dwm.c
@@ -51,6 +51,7 @@
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
 #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
+#define MAXCOLORS               12
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
 #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
 #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
@@ -206,6 +207,7 @@ static void setup(void);
 static void showhide(Client *c);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
+static int stextwidth(void);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *);
@@ -261,7 +263,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static Bool running = True;
 static Cur *cursor[CurLast];
-static ClrScheme scheme[SchemeLast];
+static ClrScheme scheme[MAXCOLORS];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -273,6 +275,9 @@ static Window root;
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
+/* compile-time check if we have mandatory schemes and all colorschemes fit into scheme array. */
+struct NumColors { char limitexceeded[LENGTH(colorschemes) > MAXCOLORS || LENGTH(colorschemes) < SchemeLast ? -1 : 1]; };
+
 /* function implementations */
 void
 applyrules(Client *c) {
@@ -432,7 +437,7 @@ buttonpress(XEvent *e) {
 		}
 		else if(ev->x < x + blw)
 			click = ClkLtSymbol;
-		else if(ev->x > selmon->ww - TEXTW(stext))
+		else if(ev->x > selmon->ww - stextwidth())
 			click = ClkStatusText;
 		else
 			click = ClkWinTitle;
@@ -474,7 +479,7 @@ cleanup(void) {
 		cleanupmon(mons);
 	for(i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for(i = 0; i < SchemeLast; i++) {
+	for(i = 0; i < LENGTH(colorschemes); i++) {
 		drw_clr_free(scheme[i].border);
 		drw_clr_free(scheme[i].bg);
 		drw_clr_free(scheme[i].fg);
@@ -689,7 +694,8 @@ dirtomon(int dir) {
 
 void
 drawbar(Monitor *m) {
-	int x, xx, w, dx;
+	char *ptr, *buf, ch;
+	int x, xx, w, ww, dx, s;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
@@ -715,13 +721,32 @@ drawbar(Monitor *m) {
 	x += w;
 	xx = x;
 	if(m == selmon) { /* status is only drawn on selected monitor */
-		w = TEXTW(stext);
-		x = m->ww - w;
+		ww = stextwidth();
+		x = m->ww - ww;
 		if(x < xx) {
 			x = xx;
-			w = m->ww - xx;
+			ww = m->ww - xx;
+		}
+		s = 1;
+		ptr = buf = stext;
+		while (*ptr) {
+			for (i = 0; *ptr < 0 || *ptr > LENGTH(colorschemes); ++i, ++ptr);
+			ch = *ptr;
+			*ptr = 0;
+			w = TEXTW(buf);
+			if (x + w > m->ww) {
+				w = m->ww - x;
+			}
+			drw_setscheme(drw, &scheme[s - 1]);
+			drw_text(drw, x, 0, w, bh, buf, 0);
+			*ptr = ch;
+			x += w;
+			if (!*ptr || x >= m->ww)
+				break;
+			s = *ptr;
+			buf = ++ptr;
 		}
-		drw_text(drw, x, 0, w, bh, stext, 0);
+		x = m->ww - ww;
 	}
 	else
 		x = m->ww;
@@ -1496,6 +1521,7 @@ setmfact(const Arg *arg) {
 
 void
 setup(void) {
+	int i;
 	XSetWindowAttributes wa;
 
 	/* clean up any zombies immediately */
@@ -1530,12 +1556,11 @@ setup(void) {
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme[SchemeNorm].border = drw_clr_create(drw, normbordercolor);
-	scheme[SchemeNorm].bg = drw_clr_create(drw, normbgcolor);
-	scheme[SchemeNorm].fg = drw_clr_create(drw, normfgcolor);
-	scheme[SchemeSel].border = drw_clr_create(drw, selbordercolor);
-	scheme[SchemeSel].bg = drw_clr_create(drw, selbgcolor);
-	scheme[SchemeSel].fg = drw_clr_create(drw, selfgcolor);
+	for(i = 0; i < LENGTH(colorschemes); ++i) {
+		scheme[i].border = drw_clr_create(drw, colorschemes[i][0]);
+		scheme[i].bg = drw_clr_create(drw, colorschemes[i][1]);
+		scheme[i].fg = drw_clr_create(drw, colorschemes[i][2]);
+	}
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1591,6 +1616,24 @@ spawn(const Arg *arg) {
 	}
 }
 
+int
+stextwidth(void) {
+	char *ptr = stext, *buf = stext, ch;
+	int i, w = 0;
+
+	while(*ptr) {
+		for(i = 0; *ptr < 0 || *ptr > LENGTH(colorschemes); ++i, ++ptr);
+		ch = *ptr;
+		*ptr = 0;
+		w += TEXTW(buf);
+		*ptr = ch;
+		if (!*ptr)
+			break;
+		buf = ++ptr;
+	}
+	return w;
+}
+
 void
 tag(const Arg *arg) {
 	if(selmon->sel && arg->ui & TAGMASK) {
