diff --git a/config.def.h b/config.def.h
index 3fde3cf..a67cc00 100644
--- a/config.def.h
+++ b/config.def.h
@@ -4,17 +4,31 @@
 static const char *fonts[] = {
 	"monospace:size=10"
 };
-static const char dmenufont[]       = "monospace:size=10";
-static const char normbordercolor[] = "#444444";
-static const char normbgcolor[]     = "#222222";
-static const char normfgcolor[]     = "#bbbbbb";
-static const char selbordercolor[]  = "#005577";
-static const char selbgcolor[]      = "#005577";
-static const char selfgcolor[]      = "#eeeeee";
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const Bool showbar           = True;     /* False means no bar */
-static const Bool topbar            = True;     /* False means bottom bar */
+static const char dmenufont[]		= "monospace:size=10";
+static const char dmenunormbgcolor[]	= "#222222";
+static const char dmenunormfgcolor[]	= "#bbbbbb";
+static const char dmenuselbgcolor[]	= "#005577";
+static const char dmenuselfgcolor[]	= "#eeeeee";
+static const unsigned int borderpx  	= 1;        /* border pixel of windows */
+static const unsigned int snap      	= 32;       /* snap pixel */
+static const Bool showbar           	= True;     /* False means no bar */
+static const Bool topbar            	= True;     /* False means bottom bar */
+
+/* colors */
+static const char *colors[] = {
+	"#444444",
+	"#222222",
+	"#bbbbbb",
+	"#005577",
+	"#eeeeee",
+};
+
+static const size_t normbordercolorid = 0;
+static const size_t normbgcolorid     = 1;
+static const size_t normfgcolorid     = 2;
+static const size_t selbordercolorid  = 3;
+static const size_t selbgcolorid      = 3;
+static const size_t selfgcolorid      = 4;
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
@@ -41,6 +55,8 @@ static const Layout layouts[] = {
 	{ "[M]",      monocle },
 };
 
+static const char monocleformat[] = "[%d]";
+
 /* key definitions */
 #define MODKEY Mod1Mask
 #define TAGKEYS(KEY,TAG) \
@@ -54,7 +70,7 @@ static const Layout layouts[] = {
 
 /* commands */
 static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", dmenunormbgcolor, "-nf", dmenunormfgcolor, "-sb", dmenuselbgcolor, "-sf", dmenuselfgcolor, NULL };
 static const char *termcmd[]  = { "st", NULL };
 
 static Key keys[] = {
diff --git a/drw.c b/drw.c
index f49200b..139127e 100644
--- a/drw.c
+++ b/drw.c
@@ -10,12 +10,58 @@
 
 #define UTF_INVALID 0xFFFD
 #define UTF_SIZ     4
+#define ANSI_ESC    '\x1B'
 
 static const unsigned char utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
 static const unsigned char utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
 static const long utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
 static const long utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
+static int
+parseansiescape(Drw *drw, const char *text)
+{
+	const char *t = text, *ec;
+	char *end;
+	int isfg, color = -1;
+	long code;
+
+	if (*(t++) == ANSI_ESC && *(t++) == '[') {
+		if (*t == '3' || *t == '4') {
+			isfg = (*t == '3');
+			code = (long)(*(++t) - '0');
+			if (code <= 8 && code >= 0) {
+				if (code != 8) {
+					if (*(++t) == 'm') {
+						++t;
+						color = code;
+					}
+				} else {
+					if (*(++t) == ';' && *(++t) == '5' && *(++t) == ';') {
+						for (ec = ++t; *ec && *ec != 'm'; ++ec);
+						if (*ec && t != ec) {
+							code = strtol(t, &end, 10);
+							if (end == ec && code >= 0 && code <= 255) {
+								t = ++ec;
+								color = code;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (color != -1 && color < drw->colorcount) {
+		if (isfg) {
+			drw->fg = color;
+		} else {
+			drw->bg = color;
+		}
+		return t - text;
+	}
+	return 0;
+}
+
 static long
 utf8decodebyte(const char c, size_t *i)
 {
@@ -60,6 +106,11 @@ utf8decode(const char *c, long *u, size_t clen)
 	return len;
 }
 
+static int
+verifycolors(Drw *drw) {
+	return drw->bg < drw->colorcount && drw->fg < drw->colorcount;
+}
+
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
 {
@@ -96,6 +147,8 @@ drw_free(Drw *drw)
 
 	for (i = 0; i < drw->fontcount; i++)
 		drw_font_free(drw->fonts[i]);
+	for (i = 0; i < drw->colorcount; i++)
+		drw_clr_free(drw->colors[i]);
 	XFreePixmap(drw->dpy, drw->drawable);
 	XFreeGC(drw->dpy, drw->gc);
 	free(drw);
@@ -201,28 +254,25 @@ drw_clr_free(Clr *clr)
 }
 
 void
-drw_setscheme(Drw *drw, ClrScheme *scheme)
-{
-	drw->scheme = scheme;
-}
-
-void
 drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert)
 {
-	if (!drw->scheme)
+	if (!verifycolors(drw))
 		return;
-	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme->bg->pix : drw->scheme->fg->pix);
+	XSetForeground(drw->dpy, drw->gc, drw->colors[invert ? drw->bg : drw->fg]->pix);
 	if (filled)
 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w + 1, h + 1);
 	else if (empty)
 		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 }
 
+
 int
 drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert)
 {
 	char buf[1024];
 	int tx, ty, th;
+	int isfirstpass = 1;
+	int iscolordelimiter;
 	Extnts tex;
 	XftDraw *d = NULL;
 	Fnt *curfont, *nextfont;
@@ -236,26 +286,36 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 	XftResult result;
 	int charexists = 0;
 
-	if (!drw->scheme || !drw->fontcount)
+	if (!verifycolors(drw) || !drw->fontcount)
 		return 0;
 
 	if (!(render = x || y || w || h)) {
 		w = ~w;
 	} else {
-		XSetForeground(drw->dpy, drw->gc, invert ?
-		               drw->scheme->fg->pix : drw->scheme->bg->pix);
-		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 		d = XftDrawCreate(drw->dpy, drw->drawable,
 		                  DefaultVisual(drw->dpy, drw->screen),
 		                  DefaultColormap(drw->dpy, drw->screen));
 	}
 
 	curfont = drw->fonts[0];
-	while (1) {
+	tx = drw->fonts[0]->h / 2;
+	while (w > tx) {
+		iscolordelimiter = 0;
 		utf8strlen = 0;
 		utf8str = text;
 		nextfont = NULL;
 		while (*text) {
+			if (*text == ANSI_ESC) {
+				if (!utf8strlen) {
+					len = MAX(parseansiescape(drw, text), 1);
+					text += len;
+					utf8str += len;
+					continue;
+				} else {
+					iscolordelimiter = 1;
+					break;
+				}
+			}
 			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
 			for (i = 0; i < drw->fontcount; i++) {
 				charexists = charexists || XftCharExists(drw->dpy, drw->fonts[i]->xfont, utf8codepoint);
@@ -277,22 +337,33 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 		}
 
 		if (utf8strlen) {
+			if (isfirstpass) {
+				/* left margin */
+				if (render) {
+					XSetForeground(drw->dpy, drw->gc, drw->colors[invert ? drw->fg : drw->bg]->pix);
+					XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, tx, h);
+					x += tx;
+					w -= tx;
+				}
+				isfirstpass = 0;
+			}
 			drw_font_getexts(curfont, utf8str, utf8strlen, &tex);
 			/* shorten text if necessary */
-			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - drw->fonts[0]->h || w < drw->fonts[0]->h); len--)
+			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - tx || w < tx); len--)
 				drw_font_getexts(curfont, utf8str, len, &tex);
 
 			if (len) {
 				memcpy(buf, utf8str, len);
 				buf[len] = '\0';
 				if (len < utf8strlen)
-					for (i = len; i && i > len - 3; buf[--i] = '.');
+					for (i = len; i && i > MAX(len, 3) - 3; buf[--i] = '.');
 
 				if (render) {
 					th = curfont->ascent + curfont->descent;
 					ty = y + (h / 2) - (th / 2) + curfont->ascent;
-					tx = x + (h / 2);
-					XftDrawStringUtf8(d, invert ? &drw->scheme->bg->rgb : &drw->scheme->fg->rgb, curfont->xfont, tx, ty, (XftChar8 *)buf, len);
+					XSetForeground(drw->dpy, drw->gc, drw->colors[invert ? drw->fg : drw->bg]->pix);
+					XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, tex.w, h);
+					XftDrawStringUtf8(d, &drw->colors[invert ? drw->bg : drw->fg]->rgb, curfont->xfont, x, ty, (XftChar8 *)buf, len);
 				}
 				x += tex.w;
 				w -= tex.w;
@@ -304,6 +375,8 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 		} else if (nextfont) {
 			charexists = 0;
 			curfont = nextfont;
+		} else if (iscolordelimiter) {
+			charexists = 0;
 		} else {
 			/* Regardless of whether or not a fallback font is found, the
 			 * character must be drawn.
@@ -344,8 +417,13 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *tex
 			}
 		}
 	}
-	if (d)
+	/* right margin */
+	if (d) {
+		XSetForeground(drw->dpy, drw->gc, drw->colors[invert ? drw->fg : drw->bg]->pix);
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+		x += w;
 		XftDrawDestroy(d);
+	}
 
 	return x;
 }
@@ -396,3 +474,17 @@ drw_cur_free(Drw *drw, Cur *cursor)
 	XFreeCursor(drw->dpy, cursor->cursor);
 	free(cursor);
 }
+
+void
+drw_setbg(Drw *drw, size_t bg) {
+	if (bg < drw->colorcount) {
+		drw->bg = bg;
+	}
+}
+
+void
+drw_setfg(Drw *drw, size_t fg) {
+	if (fg < drw->colorcount) {
+		drw->fg = fg;
+	}
+}
diff --git a/drw.h b/drw.h
index e3b8515..d4b19e3 100644
--- a/drw.h
+++ b/drw.h
@@ -1,5 +1,6 @@
 /* See LICENSE file for copyright and license details. */
 #define DRW_FONT_CACHE_SIZE 32
+#define DRW_COLOR_CACHE_SIZE 256
 
 typedef struct {
 	unsigned long pix;
@@ -20,19 +21,16 @@ typedef struct {
 } Fnt;
 
 typedef struct {
-	Clr *fg;
-	Clr *bg;
-	Clr *border;
-} ClrScheme;
-
-typedef struct {
 	unsigned int w, h;
 	Display *dpy;
 	int screen;
 	Window root;
 	Drawable drawable;
 	GC gc;
-	ClrScheme *scheme;
+	size_t bg;
+	size_t fg;
+	size_t colorcount;
+	Clr *colors[DRW_COLOR_CACHE_SIZE];
 	size_t fontcount;
 	Fnt *fonts[DRW_FONT_CACHE_SIZE];
 } Drw;
@@ -63,8 +61,8 @@ Cur *drw_cur_create(Drw *, int);
 void drw_cur_free(Drw *, Cur *);
 
 /* Drawing context manipulation */
-void drw_setfont(Drw *, Fnt *);
-void drw_setscheme(Drw *, ClrScheme *);
+void drw_setbg(Drw *, size_t);
+void drw_setfg(Drw *, size_t);
 
 /* Drawing functions */
 void drw_rect(Drw *, int, int, unsigned int, unsigned int, int, int, int);
diff --git a/dwm.c b/dwm.c
index 96b43f7..59ff20f 100644
--- a/dwm.c
+++ b/dwm.c
@@ -59,7 +59,6 @@
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-enum { SchemeNorm, SchemeSel, SchemeLast }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState,
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
@@ -112,7 +111,7 @@ typedef struct {
 } Layout;
 
 struct Monitor {
-	char ltsymbol[16];
+	char ltsymbol[256];
 	float mfact;
 	int nmaster;
 	int num;
@@ -236,7 +235,7 @@ static void zoom(const Arg *arg);
 
 /* variables */
 static const char broken[] = "broken";
-static char stext[256];
+static char stext[4096];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
@@ -261,7 +260,6 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static Bool running = True;
 static Cur *cursor[CurLast];
-static ClrScheme scheme[SchemeLast];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -273,6 +271,9 @@ static Window root;
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
+/* compile-time check if all colors fit in the colors array. */
+struct NumColors { char limitexceeded[LENGTH(colors) > DRW_COLOR_CACHE_SIZE ? -1 : 1]; };
+
 /* function implementations */
 void
 applyrules(Client *c) {
@@ -474,11 +475,6 @@ cleanup(void) {
 		cleanupmon(mons);
 	for(i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for(i = 0; i < SchemeLast; i++) {
-		drw_clr_free(scheme[i].border);
-		drw_clr_free(scheme[i].bg);
-		drw_clr_free(scheme[i].fg);
-	}
 	drw_free(drw);
 	XSync(dpy, False);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
@@ -689,7 +685,7 @@ dirtomon(int dir) {
 
 void
 drawbar(Monitor *m) {
-	int x, xx, w, dx;
+	int x, xx, w, dx, issel;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
@@ -703,14 +699,17 @@ drawbar(Monitor *m) {
 	x = 0;
 	for(i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
-		drw_setscheme(drw, m->tagset[m->seltags] & 1 << i ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
+		issel = m->tagset[m->seltags] & 1 << i;
+		drw_setbg(drw, issel ? selbgcolorid : normbgcolorid);
+		drw_setfg(drw, issel ? selfgcolorid : normfgcolorid);
 		drw_text(drw, x, 0, w, bh, tags[i], urg & 1 << i);
 		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
 		           occ & 1 << i, urg & 1 << i);
 		x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, &scheme[SchemeNorm]);
+	drw_setbg(drw, normbgcolorid);
+	drw_setfg(drw, normfgcolorid);
 	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
 	x += w;
 	xx = x;
@@ -721,6 +720,8 @@ drawbar(Monitor *m) {
 			x = xx;
 			w = m->ww - xx;
 		}
+		drw_setbg(drw, normbgcolorid);
+		drw_setfg(drw, normfgcolorid);
 		drw_text(drw, x, 0, w, bh, stext, 0);
 	}
 	else
@@ -728,12 +729,15 @@ drawbar(Monitor *m) {
 	if((w = x - xx) > bh) {
 		x = xx;
 		if(m->sel) {
-			drw_setscheme(drw, m == selmon ? &scheme[SchemeSel] : &scheme[SchemeNorm]);
+			issel = m == selmon;
+			drw_setbg(drw, issel ? selbgcolorid : normbgcolorid);
+			drw_setfg(drw, issel ? selfgcolorid : normfgcolorid);
 			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
 			drw_rect(drw, x + 1, 1, dx, dx, m->sel->isfixed, m->sel->isfloating, 0);
 		}
 		else {
-			drw_setscheme(drw, &scheme[SchemeNorm]);
+			drw_setbg(drw, normbgcolorid);
+			drw_setfg(drw, normfgcolorid);
 			drw_rect(drw, x, 0, w, bh, 1, 0, 1);
 		}
 	}
@@ -791,7 +795,7 @@ focus(Client *c) {
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, True);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel].border->pix);
+		XSetWindowBorder(dpy, c->win, drw->colors[selbordercolorid]->pix);
 		setfocus(c);
 	}
 	else {
@@ -1038,7 +1042,7 @@ manage(Window w, XWindowAttributes *wa) {
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, w, drw->colors[normbordercolorid]->pix);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1094,7 +1098,7 @@ monocle(Monitor *m) {
 		if(ISVISIBLE(c))
 			n++;
 	if(n > 0) /* override layout symbol */
-		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
+		snprintf(m->ltsymbol, sizeof m->ltsymbol, monocleformat, n);
 	for(c = nexttiled(m->clients); c; c = nexttiled(c->next))
 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, False);
 }
@@ -1496,6 +1500,7 @@ setmfact(const Arg *arg) {
 
 void
 setup(void) {
+	int i;
 	XSetWindowAttributes wa;
 
 	/* clean up any zombies immediately */
@@ -1530,12 +1535,10 @@ setup(void) {
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme[SchemeNorm].border = drw_clr_create(drw, normbordercolor);
-	scheme[SchemeNorm].bg = drw_clr_create(drw, normbgcolor);
-	scheme[SchemeNorm].fg = drw_clr_create(drw, normfgcolor);
-	scheme[SchemeSel].border = drw_clr_create(drw, selbordercolor);
-	scheme[SchemeSel].bg = drw_clr_create(drw, selbgcolor);
-	scheme[SchemeSel].fg = drw_clr_create(drw, selfgcolor);
+	drw->colorcount = LENGTH(colors);
+	for (i = 0; i < LENGTH(colors); ++i) {
+		drw->colors[i] = drw_clr_create(drw, colors[i]);
+	}
 	/* init bars */
 	updatebars();
 	updatestatus();
@@ -1684,7 +1687,7 @@ unfocus(Client *c, Bool setfocus) {
 	if(!c)
 		return;
 	grabbuttons(c, False);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm].border->pix);
+	XSetWindowBorder(dpy, c->win, drw->colors[normbordercolorid]->pix);
 	if(setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
